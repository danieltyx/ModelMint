{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac } from \"@ethersproject/sha2\";\nexport function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n  password = arrayify(password);\n  salt = arrayify(salt);\n  let hLen;\n  let l = 1;\n  const DK = new Uint8Array(keylen);\n  const block1 = new Uint8Array(salt.length + 4);\n  block1.set(salt); //salt.copy(block1, 0, 0, salt.length)\n\n  let r;\n  let T;\n\n  for (let i = 1; i <= l; i++) {\n    //block1.writeUInt32BE(i, salt.length)\n    block1[salt.length] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i & 0xff; //let U = createHmac(password).update(block1).digest();\n\n    let U = arrayify(computeHmac(hashAlgorithm, password, block1));\n\n    if (!hLen) {\n      hLen = U.length;\n      T = new Uint8Array(hLen);\n      l = Math.ceil(keylen / hLen);\n      r = keylen - (l - 1) * hLen;\n    } //U.copy(T, 0, 0, hLen)\n\n\n    T.set(U);\n\n    for (let j = 1; j < iterations; j++) {\n      //U = createHmac(password).update(U).digest();\n      U = arrayify(computeHmac(hashAlgorithm, password, U));\n\n      for (let k = 0; k < hLen; k++) T[k] ^= U[k];\n    }\n\n    const destPos = (i - 1) * hLen;\n    const len = i === l ? r : hLen; //T.copy(DK, destPos, 0, len)\n\n    DK.set(arrayify(T).slice(0, len), destPos);\n  }\n\n  return hexlify(DK);\n}","map":{"version":3,"mappings":"AAAA;;AAEA,SAASA,QAAT,EAA8BC,OAA9B,QAA6C,sBAA7C;AACA,SAASC,WAAT,QAAgD,qBAAhD;AAEA,OAAM,SAAUC,MAAV,CAAiBC,QAAjB,EAAsCC,IAAtC,EAAuDC,UAAvD,EAA2EC,MAA3E,EAA2FC,aAA3F,EAAgH;EAClHJ,QAAQ,GAAGJ,QAAQ,CAACI,QAAD,CAAnB;EACAC,IAAI,GAAGL,QAAQ,CAACK,IAAD,CAAf;EACA,IAAII,IAAJ;EACA,IAAIC,CAAC,GAAG,CAAR;EACA,MAAMC,EAAE,GAAG,IAAIC,UAAJ,CAAeL,MAAf,CAAX;EACA,MAAMM,MAAM,GAAG,IAAID,UAAJ,CAAeP,IAAI,CAACS,MAAL,GAAc,CAA7B,CAAf;EACAD,MAAM,CAACE,GAAP,CAAWV,IAAX,EAPkH,CAQlH;;EAEA,IAAIW,CAAJ;EACA,IAAIC,CAAJ;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIR,CAArB,EAAwBQ,CAAC,EAAzB,EAA6B;IACzB;IACAL,MAAM,CAACR,IAAI,CAACS,MAAN,CAAN,GAAuBI,CAAC,IAAI,EAAN,GAAY,IAAlC;IACAL,MAAM,CAACR,IAAI,CAACS,MAAL,GAAc,CAAf,CAAN,GAA2BI,CAAC,IAAI,EAAN,GAAY,IAAtC;IACAL,MAAM,CAACR,IAAI,CAACS,MAAL,GAAc,CAAf,CAAN,GAA2BI,CAAC,IAAI,CAAN,GAAW,IAArC;IACAL,MAAM,CAACR,IAAI,CAACS,MAAL,GAAc,CAAf,CAAN,GAA0BI,CAAC,GAAG,IAA9B,CALyB,CAOzB;;IACA,IAAIC,CAAC,GAAGnB,QAAQ,CAACE,WAAW,CAAqBM,aAArB,EAAoCJ,QAApC,EAA8CS,MAA9C,CAAZ,CAAhB;;IAEA,IAAI,CAACJ,IAAL,EAAW;MACPA,IAAI,GAAGU,CAAC,CAACL,MAAT;MACAG,CAAC,GAAG,IAAIL,UAAJ,CAAeH,IAAf,CAAJ;MACAC,CAAC,GAAGU,IAAI,CAACC,IAAL,CAAUd,MAAM,GAAGE,IAAnB,CAAJ;MACAO,CAAC,GAAGT,MAAM,GAAG,CAACG,CAAC,GAAG,CAAL,IAAUD,IAAvB;IACH,CAfwB,CAiBzB;;;IACAQ,CAAC,CAACF,GAAF,CAAMI,CAAN;;IAGA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,UAApB,EAAgCgB,CAAC,EAAjC,EAAqC;MACjC;MACAH,CAAC,GAAGnB,QAAQ,CAACE,WAAW,CAAqBM,aAArB,EAAoCJ,QAApC,EAA8Ce,CAA9C,CAAZ,CAAZ;;MACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,IAApB,EAA0Bc,CAAC,EAA3B,EAA+BN,CAAC,CAACM,CAAD,CAAD,IAAQJ,CAAC,CAACI,CAAD,CAAT;IAClC;;IAGD,MAAMC,OAAO,GAAG,CAACN,CAAC,GAAG,CAAL,IAAUT,IAA1B;IACA,MAAMgB,GAAG,GAAIP,CAAC,KAAKR,CAAN,GAAUM,CAAV,GAAcP,IAA3B,CA7ByB,CA8BzB;;IACAE,EAAE,CAACI,GAAH,CAAOf,QAAQ,CAACiB,CAAD,CAAR,CAAYS,KAAZ,CAAkB,CAAlB,EAAqBD,GAArB,CAAP,EAAkCD,OAAlC;EACH;;EAED,OAAOvB,OAAO,CAACU,EAAD,CAAd;AACH","names":["arrayify","hexlify","computeHmac","pbkdf2","password","salt","iterations","keylen","hashAlgorithm","hLen","l","DK","Uint8Array","block1","length","set","r","T","i","U","Math","ceil","j","k","destPos","len","slice"],"sources":["/Users/tingyandeng/Documents/GitHub/ModelGPT/marketplace/NFT-Marketplace-Tutorial-master/node_modules/@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n"]},"metadata":{},"sourceType":"module"}