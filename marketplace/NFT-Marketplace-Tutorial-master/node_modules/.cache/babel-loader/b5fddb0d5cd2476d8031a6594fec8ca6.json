{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n} // Crawl up the constructor chain to find a static method\n\nexport function getStatic(ctor, key) {\n  for (let i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n\n  return null;\n}\nexport function resolveProperties(object) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const promises = Object.keys(object).map(key => {\n      const value = object[key];\n      return Promise.resolve(value).then(v => ({\n        key: key,\n        value: v\n      }));\n    });\n    const results = yield Promise.all(promises);\n    return results.reduce((accum, result) => {\n      accum[result.key] = result.value;\n      return accum;\n    }, {});\n  });\n}\nexport function checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n\n  Object.keys(object).forEach(key => {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\nexport function shallowCopy(object) {\n  const result = {};\n\n  for (const key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n}\nconst opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\n\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n\n    const keys = Object.keys(object);\n\n    for (let i = 0; i < keys.length; i++) {\n      let value = null;\n\n      try {\n        value = object[keys[i]];\n      } catch (error) {\n        // If accessing a value triggers an error, it is a getter\n        // designed to do so (e.g. Result) and is therefore \"frozen\"\n        continue;\n      }\n\n      if (!_isFrozen(value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n} // Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\n\n\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  } // Arrays are mutable, so we need to create a copy\n\n\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(item => deepCopy(item)));\n  }\n\n  if (typeof object === \"object\") {\n    const result = {};\n\n    for (const key in object) {\n      const value = object[key];\n\n      if (value === undefined) {\n        continue;\n      }\n\n      defineReadOnly(result, key, deepCopy(value));\n    }\n\n    return result;\n  }\n\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n\nexport function deepCopy(object) {\n  return _deepCopy(object);\n}\nexport class Description {\n  constructor(info) {\n    for (const key in info) {\n      this[key] = deepCopy(info[key]);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Logger","version","logger","defineReadOnly","object","name","value","Object","defineProperty","enumerable","writable","getStatic","ctor","key","i","prototype","getPrototypeOf","constructor","resolveProperties","promises","keys","map","Promise","resolve","then","v","results","all","reduce","accum","result","checkProperties","properties","throwArgumentError","forEach","shallowCopy","opaque","bigint","boolean","number","string","_isFrozen","undefined","Array","isArray","isFrozen","length","error","_deepCopy","freeze","item","deepCopy","Description","info"],"sources":["/Users/tingyandeng/Documents/GitHub/ModelGPT/marketplace/NFT-Marketplace-Tutorial-master/node_modules/@ethersproject/properties/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}