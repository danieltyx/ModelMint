{"ast":null,"code":"import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nexport function isValidName(name) {\n  try {\n    const comps = name.split(\".\");\n\n    for (let i = 0; i < comps.length; i++) {\n      if (nameprep(comps[i]).length === 0) {\n        throw new Error(\"empty\");\n      }\n    }\n\n    return true;\n  } catch (error) {}\n\n  return false;\n}\nexport function namehash(name) {\n  /* istanbul ignore if */\n  if (typeof name !== \"string\") {\n    logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n  }\n\n  let current = name;\n  let result = Zeros;\n\n  while (current.length) {\n    const partition = current.match(Partition);\n\n    if (partition == null || partition[2] === \"\") {\n      logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n    }\n\n    const label = toUtf8Bytes(nameprep(partition[3]));\n    result = keccak256(concat([result, keccak256(label)]));\n    current = partition[2] || \"\";\n  }\n\n  return hexlify(result);\n}\nexport function dnsEncode(name) {\n  return hexlify(concat(name.split(\".\").map(comp => {\n    // We jam in an _ prefix to fill in with the length later\n    // Note: Nameprep throws if the component is over 63 bytes\n    const bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n    bytes[0] = bytes.length - 1;\n    return bytes;\n  }))) + \"00\";\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,OAAjB,QAAgC,sBAAhC;AACA,SAASC,QAAT,EAAmBC,WAAnB,QAAsC,wBAAtC;AACA,SAASC,SAAT,QAA0B,0BAA1B;AAEA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,MAAMC,MAAM,GAAG,IAAIF,MAAJ,CAAWC,OAAX,CAAf;AAEA,MAAME,KAAK,GAAG,IAAIC,UAAJ,CAAe,EAAf,CAAd;AACAD,KAAK,CAACE,IAAN,CAAW,CAAX;AAEA,MAAMC,SAAS,GAAG,IAAIC,MAAJ,CAAW,qBAAX,CAAlB;AAEA,OAAM,SAAUC,WAAV,CAAsBC,IAAtB,EAAkC;EACpC,IAAI;IACA,MAAMC,KAAK,GAAGD,IAAI,CAACE,KAAL,CAAW,GAAX,CAAd;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;MACnC,IAAIf,QAAQ,CAACa,KAAK,CAACE,CAAD,CAAN,CAAR,CAAmBC,MAAnB,KAA8B,CAAlC,EAAqC;QACjC,MAAM,IAAIC,KAAJ,CAAU,OAAV,CAAN;MACH;IACJ;;IACD,OAAO,IAAP;EACH,CARD,CAQE,OAAOC,KAAP,EAAc,CAAG;;EACnB,OAAO,KAAP;AACH;AAED,OAAM,SAAUC,QAAV,CAAmBP,IAAnB,EAA+B;EACjC;EACA,IAAI,OAAOA,IAAP,KAAiB,QAArB,EAA+B;IAC3BP,MAAM,CAACe,kBAAP,CAA0B,gCAA1B,EAA4D,MAA5D,EAAoER,IAApE;EACH;;EAED,IAAIS,OAAO,GAAGT,IAAd;EACA,IAAIU,MAAM,GAAwBhB,KAAlC;;EACA,OAAOe,OAAO,CAACL,MAAf,EAAuB;IACnB,MAAMO,SAAS,GAAGF,OAAO,CAACG,KAAR,CAAcf,SAAd,CAAlB;;IACA,IAAIc,SAAS,IAAI,IAAb,IAAqBA,SAAS,CAAC,CAAD,CAAT,KAAiB,EAA1C,EAA8C;MAC1ClB,MAAM,CAACe,kBAAP,CAA0B,wCAA1B,EAAoE,MAApE,EAA4ER,IAA5E;IACH;;IACD,MAAMa,KAAK,GAAGxB,WAAW,CAACD,QAAQ,CAACuB,SAAS,CAAC,CAAD,CAAV,CAAT,CAAzB;IACAD,MAAM,GAAGpB,SAAS,CAACJ,MAAM,CAAC,CAACwB,MAAD,EAASpB,SAAS,CAACuB,KAAD,CAAlB,CAAD,CAAP,CAAlB;IAEAJ,OAAO,GAAGE,SAAS,CAAC,CAAD,CAAT,IAAgB,EAA1B;EACH;;EAED,OAAOxB,OAAO,CAACuB,MAAD,CAAd;AACH;AAED,OAAM,SAAUI,SAAV,CAAoBd,IAApB,EAAgC;EAClC,OAAOb,OAAO,CAACD,MAAM,CAACc,IAAI,CAACE,KAAL,CAAW,GAAX,EAAgBa,GAAhB,CAAqBC,IAAD,IAAS;IAC/C;IACA;IACA,MAAMC,KAAK,GAAG5B,WAAW,CAAC,MAAMD,QAAQ,CAAC4B,IAAD,CAAf,CAAzB;IACAC,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAACb,MAAN,GAAe,CAA1B;IACA,OAAOa,KAAP;EACH,CANqB,CAAD,CAAP,CAAP,GAMA,IANP;AAOH","names":["concat","hexlify","nameprep","toUtf8Bytes","keccak256","Logger","version","logger","Zeros","Uint8Array","fill","Partition","RegExp","isValidName","name","comps","split","i","length","Error","error","namehash","throwArgumentError","current","result","partition","match","label","dnsEncode","map","comp","bytes"],"sources":["/Users/tingyandeng/Documents/GitHub/ModelGPT/marketplace/NFT-Marketplace-Tutorial-master/node_modules/@ethersproject/hash/src.ts/namehash.ts"],"sourcesContent":["import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\nexport function isValidName(name: string): boolean {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\")\n            }\n        }\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let current = name;\n    let result: string | Uint8Array = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n\n        current = partition[2] || \"\";\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(name.split(\".\").map((comp) => {\n        // We jam in an _ prefix to fill in with the length later\n        // Note: Nameprep throws if the component is over 63 bytes\n        const bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n"]},"metadata":{},"sourceType":"module"}