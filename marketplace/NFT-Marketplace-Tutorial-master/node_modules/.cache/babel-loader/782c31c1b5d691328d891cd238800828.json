{"ast":null,"code":"\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\nlet ModifiersNest = {\n  calldata: true,\n  memory: true\n};\n\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n    if (ModifiersNest[name]) {\n      return true;\n    }\n  }\n\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n\n  return false;\n} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\n\nfunction parseParamType(param, allowIndexed) {\n  let originalParam = param;\n\n  function throwError(i) {\n    logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n  }\n\n  param = param.replace(/\\s/g, \" \");\n\n  function newNode(parent) {\n    let node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n\n    return node;\n  }\n\n  let parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  let node = parent;\n\n  for (let i = 0; i < param.length; i++) {\n    let c = param[i];\n\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n\n      case \")\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        let child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case \",\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        let sibling = newNode(node.parent); //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n\n              if (node.indexed) {\n                throwError(i);\n              }\n\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n  }\n\n  delete parent.state;\n\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n\nfunction populate(object, params) {\n  for (let key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\n\nexport const FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readable with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new ParamType()\"\n      });\n    }\n\n    populate(this, params);\n    let match = this.type.match(paramTypeArray);\n\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n\n    this._isParamType = true;\n    Object.freeze(this);\n  } // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n\n\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      let result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name: this.name || undefined\n      };\n\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n\n      if (this.components) {\n        result.components = this.components.map(comp => JSON.parse(comp.format(format)));\n      }\n\n      return JSON.stringify(result);\n    }\n\n    let result = \"\"; // Array\n\n    if (this.baseType === \"array\") {\n      result += this.arrayChildren.format(format);\n      result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n    } else {\n      if (this.baseType === \"tuple\") {\n        if (format !== FormatTypes.sighash) {\n          result += this.type;\n        }\n\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n\n    if (format !== FormatTypes.sighash) {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n\n      if (format === FormatTypes.full && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n\n    return result;\n  }\n\n  static from(value, allowIndexed) {\n    if (typeof value === \"string\") {\n      return ParamType.fromString(value, allowIndexed);\n    }\n\n    return ParamType.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (ParamType.isParamType(value)) {\n      return value;\n    }\n\n    return new ParamType(_constructorGuard, {\n      name: value.name || null,\n      type: verifyType(value.type),\n      indexed: value.indexed == null ? null : !!value.indexed,\n      components: value.components ? value.components.map(ParamType.fromObject) : null\n    });\n  }\n\n  static fromString(value, allowIndexed) {\n    function ParamTypify(node) {\n      return ParamType.fromObject({\n        name: node.name,\n        type: node.type,\n        indexed: node.indexed,\n        components: node.components\n      });\n    }\n\n    return ParamTypify(parseParamType(value, !!allowIndexed));\n  }\n\n  static isParamType(value) {\n    return !!(value != null && value._isParamType);\n  }\n\n}\n;\n\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(param => ParamType.fromString(param, allowIndex));\n}\n\nexport class Fragment {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new Fragment()\"\n      });\n    }\n\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n\n  static from(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return Fragment.fromString(value);\n    }\n\n    return Fragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    switch (value.type) {\n      case \"function\":\n        return FunctionFragment.fromObject(value);\n\n      case \"event\":\n        return EventFragment.fromObject(value);\n\n      case \"constructor\":\n        return ConstructorFragment.fromObject(value);\n\n      case \"error\":\n        return ErrorFragment.fromObject(value);\n\n      case \"fallback\":\n      case \"receive\":\n        // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n        return null;\n    }\n\n    return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n  }\n\n  static fromString(value) {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    value = value.replace(/\\s/g, \" \");\n    value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n    value = value.trim();\n\n    if (value.split(\" \")[0] === \"event\") {\n      return EventFragment.fromString(value.substring(5).trim());\n    } else if (value.split(\" \")[0] === \"function\") {\n      return FunctionFragment.fromString(value.substring(8).trim());\n    } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n      return ConstructorFragment.fromString(value.trim());\n    } else if (value.split(\" \")[0] === \"error\") {\n      return ErrorFragment.fromString(value.substring(5).trim());\n    }\n\n    return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n  }\n\n  static isFragment(value) {\n    return !!(value && value._isFragment);\n  }\n\n}\nexport class EventFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    let result = \"\";\n\n    if (format !== FormatTypes.sighash) {\n      result += \"event \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== FormatTypes.sighash) {\n      if (this.anonymous) {\n        result += \"anonymous \";\n      }\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return EventFragment.fromString(value);\n    }\n\n    return EventFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (EventFragment.isEventFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"event\") {\n      logger.throwArgumentError(\"invalid event object\", \"value\", value);\n    }\n\n    const params = {\n      name: verifyIdentifier(value.name),\n      anonymous: value.anonymous,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      type: \"event\"\n    };\n    return new EventFragment(_constructorGuard, params);\n  }\n\n  static fromString(value) {\n    let match = value.match(regexParen);\n\n    if (!match) {\n      logger.throwArgumentError(\"invalid event string\", \"value\", value);\n    }\n\n    let anonymous = false;\n    match[3].split(\" \").forEach(modifier => {\n      switch (modifier.trim()) {\n        case \"anonymous\":\n          anonymous = true;\n          break;\n\n        case \"\":\n          break;\n\n        default:\n          logger.warn(\"unknown modifier: \" + modifier);\n      }\n    });\n    return EventFragment.fromObject({\n      name: match[1].trim(),\n      anonymous: anonymous,\n      inputs: parseParams(match[2], true),\n      type: \"event\"\n    });\n  }\n\n  static isEventFragment(value) {\n    return value && value._isFragment && value.type === \"event\";\n  }\n\n}\n\nfunction parseGas(value, params) {\n  params.gas = null;\n  let comps = value.split(\"@\");\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n    }\n\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n\n  return value;\n}\n\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(modifier => {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n\n      case \"nonpayable\":\n        params.payable = false;\n        params.stateMutability = \"nonpayable\";\n        break;\n\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\n\nfunction verifyState(value) {\n  let result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability; // Set (and check things are consistent) the constant property\n\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    } // Set (and check things are consistent) the payable property\n\n\n    result.payable = result.stateMutability === \"payable\";\n\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable; // If payable we can assume non-constant; otherwise we can't assume\n\n    if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n      logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    result.constant = !!value.constant;\n\n    if (result.constant) {\n      result.stateMutability = \"view\";\n    } else {\n      result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    }\n\n    if (result.payable && result.constant) {\n      logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  } else if (value.type !== \"constructor\") {\n    logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n  }\n\n  return result;\n}\n\nexport class ConstructorFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payable: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    if (format === FormatTypes.sighash) {\n      logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"format(sighash)\"\n      });\n    }\n\n    let result = \"constructor(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n      result += this.stateMutability + \" \";\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return ConstructorFragment.fromString(value);\n    }\n\n    return ConstructorFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (ConstructorFragment.isConstructorFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"constructor\") {\n      logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n    }\n\n    let state = verifyState(value);\n\n    if (state.constant) {\n      logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n    }\n\n    const params = {\n      name: null,\n      type: value.type,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    };\n    return new ConstructorFragment(_constructorGuard, params);\n  }\n\n  static fromString(value) {\n    let params = {\n      type: \"constructor\"\n    };\n    value = parseGas(value, params);\n    let parens = value.match(regexParen);\n\n    if (!parens || parens[1].trim() !== \"constructor\") {\n      logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n    }\n\n    params.inputs = parseParams(parens[2].trim(), false);\n    parseModifiers(parens[3].trim(), params);\n    return ConstructorFragment.fromObject(params);\n  }\n\n  static isConstructorFragment(value) {\n    return value && value._isFragment && value.type === \"constructor\";\n  }\n\n}\nexport class FunctionFragment extends ConstructorFragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payable: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format))),\n        outputs: this.outputs.map(output => JSON.parse(output.format(format)))\n      });\n    }\n\n    let result = \"\";\n\n    if (format !== FormatTypes.sighash) {\n      result += \"function \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== FormatTypes.sighash) {\n      if (this.stateMutability) {\n        if (this.stateMutability !== \"nonpayable\") {\n          result += this.stateMutability + \" \";\n        }\n      } else if (this.constant) {\n        result += \"view \";\n      }\n\n      if (this.outputs && this.outputs.length) {\n        result += \"returns (\" + this.outputs.map(output => output.format(format)).join(\", \") + \") \";\n      }\n\n      if (this.gas != null) {\n        result += \"@\" + this.gas.toString() + \" \";\n      }\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return FunctionFragment.fromString(value);\n    }\n\n    return FunctionFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (FunctionFragment.isFunctionFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"function\") {\n      logger.throwArgumentError(\"invalid function object\", \"value\", value);\n    }\n\n    let state = verifyState(value);\n    const params = {\n      type: value.type,\n      name: verifyIdentifier(value.name),\n      constant: state.constant,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    };\n    return new FunctionFragment(_constructorGuard, params);\n  }\n\n  static fromString(value) {\n    let params = {\n      type: \"function\"\n    };\n    value = parseGas(value, params);\n    let comps = value.split(\" returns \");\n\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid function string\", \"value\", value);\n    }\n\n    let parens = comps[0].match(regexParen);\n\n    if (!parens) {\n      logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n    }\n\n    params.name = parens[1].trim();\n\n    if (params.name) {\n      verifyIdentifier(params.name);\n    }\n\n    params.inputs = parseParams(parens[2], false);\n    parseModifiers(parens[3].trim(), params); // We have outputs\n\n    if (comps.length > 1) {\n      let returns = comps[1].match(regexParen);\n\n      if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n        logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n      }\n\n      params.outputs = parseParams(returns[2], false);\n    } else {\n      params.outputs = [];\n    }\n\n    return FunctionFragment.fromObject(params);\n  }\n\n  static isFunctionFragment(value) {\n    return value && value._isFragment && value.type === \"function\";\n  }\n\n} //export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment) {\n  const sig = fragment.format();\n\n  if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n    logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n  }\n\n  return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"error\",\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    let result = \"\";\n\n    if (format !== FormatTypes.sighash) {\n      result += \"error \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return ErrorFragment.fromString(value);\n    }\n\n    return ErrorFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (ErrorFragment.isErrorFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"error\") {\n      logger.throwArgumentError(\"invalid error object\", \"value\", value);\n    }\n\n    const params = {\n      type: value.type,\n      name: verifyIdentifier(value.name),\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []\n    };\n    return checkForbidden(new ErrorFragment(_constructorGuard, params));\n  }\n\n  static fromString(value) {\n    let params = {\n      type: \"error\"\n    };\n    let parens = value.match(regexParen);\n\n    if (!parens) {\n      logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n    }\n\n    params.name = parens[1].trim();\n\n    if (params.name) {\n      verifyIdentifier(params.name);\n    }\n\n    params.inputs = parseParams(parens[2], false);\n    return checkForbidden(ErrorFragment.fromObject(params));\n  }\n\n  static isErrorFragment(value) {\n    return value && value._isFragment && value.type === \"error\";\n  }\n\n}\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  } // @TODO: more verification\n\n\n  return type;\n} // See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\n\n\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\n\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n  }\n\n  return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value) {\n  value = value.trim();\n  let result = [];\n  let accum = \"\";\n  let depth = 0;\n\n  for (let offset = 0; offset < value.length; offset++) {\n    let c = value[offset];\n\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n\n        if (depth === -1) {\n          logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["BigNumber","defineReadOnly","Logger","version","logger","_constructorGuard","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","type","name","indexOf","throwArgumentError","parseParamType","param","allowIndexed","originalParam","throwError","i","replace","newNode","parent","node","state","allowType","indexed","length","c","allowParams","verifyType","components","child","allowName","allowArray","sibling","push","readArray","populate","object","params","key","FormatTypes","Object","freeze","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","constructor","constructorGuard","errors","UNSUPPORTED_OPERATION","operation","match","arrayLength","parseInt","arrayChildren","fromObject","baseType","_isParamType","format","result","undefined","map","comp","JSON","parse","stringify","String","join","from","value","fromString","isParamType","ParamTypify","parseParams","allowIndex","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","trim","split","substring","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","log","verifyState","toNumber","isConstructorFragment","parens","outputs","output","toString","isFunctionFragment","returns","checkForbidden","fragment","sig","isErrorFragment","regexIdentifier","accum","depth","offset"],"sources":["/Users/tingyandeng/Documents/GitHub/ModelGPT/marketplace/NFT-Marketplace-Tutorial-master/node_modules/@ethersproject/abi/src.ts/fragments.ts"],"sourcesContent":["\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n"]},"metadata":{},"sourceType":"module"}